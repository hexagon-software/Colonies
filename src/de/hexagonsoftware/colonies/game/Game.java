package de.hexagonsoftware.colonies.game;

import java.awt.Color;
import java.awt.Graphics;
import java.awt.event.KeyEvent;
import java.awt.event.MouseEvent;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.ThreadLocalRandom;

import de.hexagonsoftware.colonies.Reference;
import de.hexagonsoftware.colonies.engine.Engine;
import de.hexagonsoftware.colonies.engine.graphics.GameWindow;
import de.hexagonsoftware.colonies.game.input.KeyboardInput;
import de.hexagonsoftware.colonies.game.input.MouseInput;
import de.hexagonsoftware.colonies.game.tiles.*;
import de.hexagonsoftware.colonies.game.util.PerlinNoise;
import de.hexagonsoftware.colonies.game.util.ResourceLoader;
import de.hexagonsoftware.colonies.game.util.Vector3d;

public class Game implements Runnable {
	private Engine engine;
	private GameWindow window;
	private StateMachine stateMachine;
	
	private Thread t;
	private boolean running;
	
	public int size = 7;
	private Map<Integer, Vector3d> noiseMap;
	private ITile[] tileMap = new ITile[size*size];
	
	private static double time = 0;
	
	public Game(boolean fullscreen) {
		Reference.logger.info("Initialising Game...");
		this.engine = new Engine(this, "Colonies "+Reference.VERSION, fullscreen); // Create new Game Engine instance
		this.window = engine.getWin(); // Get the GameWindow instance for convenience
		this.stateMachine = new StateMachine(this, engine); // Create a new State Machine
		this.window.setBackground(Color.white); // Set the Canvas Background Color
		
		Reference.logger.info("Initialising Input Handlers...");
		this.window.addMouseListener(new MouseInput(this)); // Add Mouse Input handler
		this.window.addKeyListener(new KeyboardInput(this)); // Add Keyboard Input Handler
		this.window.requestFocus();
		
		Reference.logger.info("Loading Game Resources...");
		ResourceLoader.loadResources(engine); // Load all Resources
		
		// Set the Icon for the Game Window
		window.getFrame().setIconImage(engine.getResourceManager().getTexture("icon"));
		
		Reference.logger.info("Generating Map...");
		this.noiseMap = new HashMap<>();
		generateMap(); // Generate a Noise Map
		translateMap(); // Translate the previously generated noise map to a tile map.
	}
	
	public void start(boolean skipSplash) {
		this.t = new Thread(this, "COLONIES");
		running = true;
		Reference.logger.info("Init Finished, entering game!");
		
		// Check if the skipSplash argument is true or false
		if (!skipSplash) {
			this.stateMachine.activateState("splash");
		} else {
			this.stateMachine.activateState("playing");
		}
		
		// Start the main game thread
		this.t.start();
	}
	
	@Override
	public void run() {
		
		long oldTimestamp = System.nanoTime();
		double ticks = 60.0;
		double ns = 1000000000 / ticks;
		double delta = 0;
		long timer = System.currentTimeMillis();
		int frames = 0;
		long now;
		int fps = 0;
		
		while(true) {
			now = System.nanoTime();
			
			delta += (now - oldTimestamp) / ns;
			oldTimestamp = now;
			
			while(delta > 1 ) {
				stateMachine.getActiveState().update();
				delta--;	
			}
			
			if (running)
				engine.getHGE().getRenderer().render(fps);
			
			frames++;
			
			if (System.currentTimeMillis() - timer > 1000) {
				timer += 1000;
				fps = frames;
				frames = 0;
			}
			
			/*try {
				Thread.sleep(15);
			} catch (InterruptedException e) {
				e.printStackTrace();
			}*/
		}
	}
	
	public void render(Graphics g, int frames) {
		stateMachine.getActiveState().render(g, frames);
	}
	
	/**
	 * Generates the Noise Map later used for the Map Generation.
	 * 
	 * @author Felix Eckert
	 * */
	private void generateMap() {
		for (int x = 0; x < size; x++) {
			for (int y = 0; y < size; y++) {
				double dx = (double) x / window.getHeight();
				double dy = (double) y / window.getWidth();
				int frequency = ThreadLocalRandom.current().nextInt(10, 1000);
				double type = PerlinNoise.noise((dx * frequency) + time, (dy * frequency) + time);
				
				noiseMap.put(x+y, new Vector3d(x, y, type));
			}
		}	
	}
	
	/**
	 * Tranlates the Noise Map generated by {@link Game#generateMap()}
	 * into the tile map used later on.
	 * */
	private void translateMap() {
		for (int i = 0; i < noiseMap.size(); i++) {
			Vector3d tile = noiseMap.get(i);
			double noise = tile.z;
			double x = tile.x;
			double y = tile.y;
			
			if (noise < NoiseVals.getValues()[0]) {
				GrassTile tempTile = new GrassTile(this);
				tempTile.setX((int) x);
				tempTile.setY((int) y);
				tileMap[i] = tempTile;
			} else {
				StoneTile tempTile = new StoneTile();
				tempTile.setX((int) x);
				tempTile.setY((int) y);
				tileMap[i] = tempTile;
			}
		}
	}
	
	public GameWindow getWindow() { return this.window; }
	public ITile[] getMap() { return this.tileMap; }
	public Engine getEngine() { return this.engine; }
	
	public StateMachine getStateMachine() {
		return stateMachine;
	}

	/* Input Handlers */
	
	public void handleMouse(MouseEvent e) {
		stateMachine.getActiveState().mousePressed(e.getX(), e.getY());
	}

	public void handleKeyUp(KeyEvent e) {
		stateMachine.getActiveState().keyReleased(e);
	}

	public void handleKeyDown(KeyEvent e) {
		stateMachine.getActiveState().keyPressed(e);
	}
}
